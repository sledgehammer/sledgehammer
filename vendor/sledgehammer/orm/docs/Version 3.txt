
ORM Duties/Goals
-----------------
 * Retrieving data from a database/datasource and inject that data into an object.
   - List
   - Read
   - Create/Update
 * Protect againt SQL injection
 * OOP aproach to database records.
  - Easily fetch related records
 * Optimize for programmer happiness


Looking back on Version 2
--------------------------
The good:
+ protection against sql injection 
+ Lazy relations
+ columns as properties (a object is a row in the db)
+ relations as properties
+ Only save/update the changes
+ config for the customer in the customer class (no boilerplate mapper classes or xml configurations)
+ A record (instance) object can't modify other records
+ Column/property validation (no silent dataloss)
+ Quick & dirty with SimpleRecord's auto-configuration
+ Strict: No first() method, find() returns 1 object or an exception
+ AutoCompletion. [with the "new RecordClass($id)" syntax];

Shady:
+ Dual mode, a alternative/difficult concept.
+ Not POCO
+ AutoCompletion not aware of static/instance mode
+ No support for greedy relations

Bad:
+ Cryptic errors on incorrect configurations.
+ Low discoverabily of functionality / Difficult to configure.


New technology available for ORM v3 
------------------------
 - Closures ($this support in 5.4)
 - Late static binding
 - Traits/Mixins (support in PHP5.4?)



The silver bullet
------------------

The class should determines the structure. 
  $customer->address->city that maps to the 'city' column in the 'customers' table.

Full support for IDE autocompletion

Only one instance per row.
  $x = new Customer(1);
  $y = new Customer(1); // $y becomes a reference to $x;
(Became $repository->getCustomer(1), the "new" keyword will allway generate a new/seperate instance)

ORM can save and retrieves POCO (Plain Old Class Objects)

Clean/short/readable SQL statements.
  No quotes around integers for ids.
  Use "*" to select all columns.


No performance penalty

Autosaving?

Don't depend on SQL, but allow it.
  Alternative datasources can't support sql.
  Allowing SQL for the datasources that support is powerfull (great featureset with great performance). 
  

Supports for multiple backends. 
  $player->tweets (player from db, tweets from the twitter API)



Concept descriptions
---------------------

POCO (Plain Old Class Objects)
  the save() / delete() methods dont make sense on all (record) objects.
  Also no inheritance of interface required.

  No direct connection between datasource and object?
  aka support for multiple database/repository connections for the same class.



Thoughts on LINQ / Entity / underscore
---------------------------------------

linq is nice, entity has migration issues (citation needed)



Thoughts and pitfalls on php 5.3 (lsb)
---------------------------------

limited IDE autocompletion?


Implementation ideas
------
= Improved mapping =
 xpath notation for mapping notation:
 column "city" to property "address/city" translates to $x->address->city; // or "address.city"? or "address->city"?
 // is 'address' a array, stdClass, ArrayObject or custom class? 
 // Getting autocompletion to work: @var AddresStruct public $address

Became "address->city" for objects and "address[city]" for arrays in PropertyPath.

= Repository =
Loading and Saving logic outside the Record object.
Aka a Repository link instead of an db_link
Repository extracts configuration from the record class but allows you to redefine those values a.k.a use a test database.

= Fake classes =
Generate fake phpClasses in the tmp/ folder to enable autocompletion for dynamic methods like Repository->findCustomer(1) 
/**
 * @return /AutoCompletionHelper/Repository 
function getRepository() {
}


= (Auto)Generated RepositoryClass =
Also generate the function body and use this class the next run.



Collection API (Table/static-mode)
-------------------

To automate controllers like the JsonCrudController
$t = $repo->getCustomerCollection(); //new Record/Table('ClassName', $repo);
// CRUD
$t->find($id);
$t->findAll($criteria);
$t->add($o); //insert
$t->update($o);
$t->delete($id);
$t->deleteAll($criteria); // Won't be implemented, would enable big mistakes in client code
// Filtering/List
$rs = $t->all();
$rs = $t->all()->where('x = 2');
foreach($rs as $record) {}


Repository API
---------------
$repository = getRepository('default');
$customer = $repository->getCustomer($id);
$customer = $repository->findCustomer($criteria);
  became $customer = $repository->getCustomerCollection()->where($criteria);
  should become $repository->getCustomers()->where($criteria);
    but both options wouldn't force 1 result (or an Exception).

$repository->saveCustomer($customer);
$table = $repository->getCustomersTable();
  
$repository->saveAll()? namespace conflict with the "All" model?
  Wouldn't this generate multiple save() call per (belongsTo/hasMany) instance? 


Record API
-----------
@property $_recordConfig => array('repository' => 'default', 'table' => 'customer', 'hasMany' => array(), 'belongsTo' => array())
or
@return RecordConfig
Record->getRecordConfig()


= abstract GenericRecord =
Has conveniance methods

new GenericRecord(id)
GenericRecord::find()
GenericRecord::findAll()
GenericRecord->save()
GenericRecord->delete()
(private)GenericRecord->_state = 'NEW'|'EXISTING'|'DELETED'
GenericRecord::$repository;


SimpleRecord
----------------
SimpleRecord inspects the repository/database and generates properties and _config.


Issues
-------
injecting values into private properties (with data from the db)
  Inject via an "SH/Record/PrivateProperties" interface? setPrivateProperties($values)
    Caller should be checked/validated?

injecting lazy-loaded relations.


Rejected ideas
---------------
Autogenerate repositories based on database connection.
'default' => new DbRepo(getDatabase('default'));
*Because* we can use one Repository instance to handle multiple database connections/schema's/backends